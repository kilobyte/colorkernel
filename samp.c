#include <stdio.h>
#include <stdint.h>

typedef uint8_t u8;

struct rgb { u8 r; u8 g; u8 b; };

int max3(int a, int b, int c)
{
    if (a > b)
        if (a > c)
            return a;
        else
            return c;
    else if (b > c)
        return b;
    else
        return c;
}

const unsigned char color_table[] = { 0, 4, 2, 6, 1, 5, 3, 7,
                                       8,12,10,14, 9,13,11,15 };

void old_from_256(int i, struct rgb *c)
{
        if (i < 8) {            /* Standard colours. */
                c->r = i&1 ? 0xaa : 0x00;
                c->g = i&2 ? 0xaa : 0x00;
                c->b = i&4 ? 0xaa : 0x00;
        } else if (i < 16) {
                c->r = i&1 ? 0xff : 0x55;
                c->g = i&2 ? 0xff : 0x55;
                c->b = i&4 ? 0xff : 0x55;
        } else if (i < 232) {   /* 6x6x6 colour cube. */
                c->r = (i - 16) / 36 * 85 / 2;
                c->g = (i - 16) / 6 % 6 * 85 / 2;
                c->b = (i - 16) % 6 * 85 / 2;
        } else                  /* Grayscale ramp. */
                c->r = c->g = c->b = i * 10 - 2312;
}

u8 old_foreground(const struct rgb *c)
{
        u8 hue = 0, max = max3(c->r, c->g, c->b);

        if (c->r > max / 2)
                hue |= 4;
        if (c->g > max / 2)
                hue |= 2;
        if (c->b > max / 2)
                hue |= 1;

        if (hue == 7 && max <= 0x55)
		return 8;

        return (max > 0xaa) ? hue|8 : hue;
}

u8 old_background(const struct rgb *c)
{
        /* For backgrounds, err on the dark side. */
        return (c->r&0x80) >> 1 | (c->g&0x80) >> 2 | (c->b&0x80) >> 3;
}

void new_from_256(int i, struct rgb *c)
{
        if (i < 8) {            /* Standard colours. */
                c->r = i&1 ? 0xaa : 0x00;
                c->g = i&2 ? 0xaa : 0x00;
                c->b = i&4 ? 0xaa : 0x00;
        } else if (i < 16) {
                c->r = i&1 ? 0xff : 0x55;
                c->g = i&2 ? 0xff : 0x55;
                c->b = i&4 ? 0xff : 0x55;
        } else if (i < 232) {   /* 6x6x6 colour cube. */
               int r = (i - 16) / 36;
               int g = (i - 16) / 6 % 6;
               int b = (i - 16) % 6;
               c->r = r ? r * 0x28 + 0x37 : 0;
               c->g = g ? g * 0x28 + 0x37 : 0;
               c->b = b ? b * 0x28 + 0x37 : 0;
        } else                  /* Grayscale ramp. */
                c->r = c->g = c->b = i * 10 - 2312;
}

u8 new_foreground(const struct rgb *c)
{
        u8 hue = 0, max = max3(c->r, c->g, c->b);

        if (c->r > max / 2 + 32)
                hue |= 4;
        if (c->g > max / 2 + 32)
                hue |= 2;
        if (c->b > max / 2 + 32)
                hue |= 1;

        if (hue == 7 && max <= 0x70)
		return 8;

        return (max > 0xc0) ? hue|8 : hue;
}

u8 new_background(const struct rgb *c)
{
        /* For backgrounds, err on the dark side. */
        return (c->r&0x80) >> 1 | (c->g&0x80) >> 2 | (c->b&0x80) >> 3;
}

// From freebsd/sys/teken/teken.c

#define	k	0
#define	b	1
#define	y	6
#define	c	3
#define	g	2
#define	m	5
#define	r	4
#define	w	7
#define	K	(k+8)
#define	B	(b+8)
#define	Y	(y+8)
#define	C	(c+8)
#define	G	(g+8)
#define	M	(m+8)
#define	R	(r+8)
#define	W	(w+8)

/**
 * The xterm-256 color map has steps of 0x28 (in the range 0-0xff), except
 * for the first step which is 0x5f.  Scale to the range 0-6 by dividing
 * by 0x28 and rounding down.  The range of 0-5 cannot represent the
 * larger first step.
 *
 * This table is generated by the follow rules:
 * - if all components are equal, the result is black for (0, 0, 0) and
 *   (2, 2, 2), else white; otherwise:
 * - subtract the smallest component from all components
 * - if this gives only one nonzero component, then that is the color
 * - else if one component is 2 or more larger than the other nonzero one,
 *   then that component gives the color
 * - else there are 2 nonzero components.  The color is that of a small
 *   equal mixture of these components (cyan, yellow or magenta).  E.g.,
 *   (0, 5, 6) (Turquoise2) is a much purer cyan than (0, 2, 3)
 *   (DeepSkyBlue4), but we map both to cyan since we can't represent
 *   delicate shades of either blue or cyan and blue would be worse.
 *   Here it is important that components of 1 never occur.  Blue would
 *   be twice as large as green in (0, 1, 2).
 */
const u8 teken_256to8tab[] = {
	/* xterm normal colors: */
	k, r, g, y, b, m, c, w,

	/* xterm bright colors: */
	k, r, g, y, b, m, c, w,

	/* Red0 submap. */
	k, b, b, b, b, b,
	g, c, c, b, b, b,
	g, c, c, c, b, b,
	g, g, c, c, c, b,
	g, g, g, c, c, c,
	g, g, g, g, c, c,

	/* Red2 submap. */
	r, m, m, b, b, b,
	y, k, b, b, b, b,
	y, g, c, c, b, b,
	g, g, c, c, c, b,
	g, g, g, c, c, c,
	g, g, g, g, c, c,

	/* Red3 submap. */
	r, m, m, m, b, b,
	y, r, m, m, b, b,
	y, y, w, b, b, b,
	y, y, g, c, c, b,
	g, g, g, c, c, c,
	g, g, g, g, c, c,

	/* Red4 submap. */
	r, r, m, m, m, b,
	r, r, m, m, m, b,
	y, y, r, m, m, b,
	y, y, y, w, b, b,
	y, y, y, g, c, c,
	g, g, g, g, c, c,

	/* Red5 submap. */
	r, r, r, m, m, m,
	r, r, r, m, m, m,
	r, r, r, m, m, m,
	y, y, y, r, m, m,
	y, y, y, y, w, b,
	y, y, y, y, g, c,

	/* Red6 submap. */
	r, r, r, r, m, m,
	r, r, r, r, m, m,
	r, r, r, r, m, m,
	r, r, r, r, m, m,
	y, y, y, y, r, m,
	y, y, y, y, y, w,

	/* Grey submap. */
	k, k, k, k, k, k,
	k, k, k, k, k, k,
	w, w, w, w, w, w,
	w, w, w, w, w, w,
};

/*
 * This table is generated from the previous one by setting TC_LIGHT for
 * entries whose luminosity in the xterm256 color map is 60% or larger.
 * Thus the previous table is currently not really needed.  It will be
 * used for different fine tuning of the tables.
 */
const u8 teken_256to16tab[] = {
	/* xterm normal colors: */
	k, r, g, y, b, m, c, w,

	/* xterm bright colors: */
	K, R, G, Y, B, M, C, W,

	/* Red0 submap. */
	k, b, b, b, b, b,
	g, c, c, b, b, b,
	g, c, c, c, b, b,
	g, g, c, c, c, b,
	g, g, g, c, c, c,
	g, g, g, g, c, c,

	/* Red2 submap. */
	r, m, m, b, b, b,
	y, K, b, b, B, B,
	y, g, c, c, B, B,
	g, g, c, c, C, B,
	g, G, G, C, C, C,
	g, G, G, G, C, C,

	/* Red3 submap. */
	r, m, m, m, b, b,
	y, r, m, m, B, B,
	y, y, w, B, B, B,
	y, y, G, C, C, B,
	g, G, G, C, C, C,
	g, G, G, G, C, C,

	/* Red4 submap. */
	r, r, m, m, m, b,
	r, r, m, m, M, B,
	y, y, R, M, M, B,
	y, y, Y, W, B, B,
	y, Y, Y, G, C, C,
	g, G, G, G, C, C,

	/* Red5 submap. */
	r, r, r, m, m, m,
	r, R, R, M, M, M,
	r, R, R, M, M, M,
	y, Y, Y, R, M, M,
	y, Y, Y, Y, W, B,
	y, Y, Y, Y, G, C,

	/* Red6 submap. */
	r, r, r, r, m, m,
	r, R, R, R, M, M,
	r, R, R, R, M, M,
	r, R, R, R, M, M,
	y, Y, Y, Y, R, M,
	y, Y, Y, Y, Y, W,

	/* Grey submap. */
	k, k, k, k, k, k,
	K, K, K, K, K, K,
	w, w, w, w, w, w,
	W, W, W, W, W, W,
};

#undef	k
#undef	b
#undef	y
#undef	c
#undef	g
#undef	m
#undef	r
#undef	w
#undef	K
#undef	B
#undef	Y
#undef	C
#undef	G
#undef	M
#undef	R
#undef	W


unsigned char default_red[] = {
        0x00, 0xaa, 0x00, 0xaa, 0x00, 0xaa, 0x00, 0xaa,
        0x55, 0xff, 0x55, 0xff, 0x55, 0xff, 0x55, 0xff
};

unsigned char default_grn[] = {
        0x00, 0x00, 0xaa, 0x55, 0x00, 0x00, 0xaa, 0xaa,
        0x55, 0x55, 0xff, 0xff, 0x55, 0x55, 0xff, 0xff
};

unsigned char default_blu[] = {
        0x00, 0x00, 0x00, 0x00, 0xaa, 0xaa, 0xaa, 0xaa,
        0x55, 0x55, 0x55, 0x55, 0xff, 0xff, 0xff, 0xff
};

void show16(int c)
{
	printf("%d;%d;%d", default_red[c], default_grn[c], default_blu[c]);
}

void show_sym(int c, const char *sym)
{
	if (!sym)
		return;
	printf("\e[38;2;");
	show16(color_table[c]);
	printf("m%s", sym);
}

const char *sym_old, *sym_new, *sym_teken;

void do_color(int i)
{
        struct rgb oc, nc;
        old_from_256(i, &oc);
        new_from_256(i, &nc);
        if (i < 16)
	        printf("\e[48;2;"), show16(i), printf("m");
	else
                printf("\e[48;5;%dm", i);
	show_sym(old_foreground(&oc), sym_old);
	show_sym(new_foreground(&nc), sym_new);
	show_sym(teken_256to16tab[i], sym_teken);
	printf("\e[0m");
}

void sampler()
{
    printf("\e[0m");
    for (int i=0; i<8; i++)
        do_color(i);
    printf("\n");
    for (int i=8; i<16; i++)
        do_color(i);
    printf(" ");
    for (int i=256-24; i<256; i++)
        do_color(i);
    printf("\n");
    printf("\n");
    for (int g=0; g<6; g++)
    {
        for (int r=0; r<6; r++)
        {
            for (int b=0; b<6; b++)
                do_color(16+r*36+g*6+b);
            printf(" ");
        }
        printf("\n");
    }
}

int main()
{
	// ◀▶ ◄► 
	printf("old vs new\n");
	sym_old=""; sym_new=""; sym_teken=0;
	sampler();
	printf("\n");
	printf("new vs teken\n");
	sym_old=0; sym_new=""; sym_teken="";
	sampler();
	return 0;
}
